#!/usr/bin/env bash
#
# bin/checkit
# Main Entry Point: Orchestrates the application flow.
#
# Responsibility: Bootstraps the environment, parses arguments,
# and dispatches execution to specific domain logic (Check, Create, Verify).

# Resolves project root to locate libraries relative to this script.
BIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
PROJECT_ROOT="$(dirname "$BIN_DIR")"

# Library imports
# shellcheck source=lib/constants.sh
source "$PROJECT_ROOT/lib/constants.sh"
# shellcheck source=lib/core/parser.sh
source "$PROJECT_ROOT/lib/core/parser.sh"
# shellcheck source=lib/core/formatter.sh
source "$PROJECT_ROOT/lib/core/formatter.sh"
# shellcheck source=lib/core/algorithm_chooser.sh
source "$PROJECT_ROOT/lib/core/algorithm_chooser.sh"
# shellcheck source=lib/adapters/hash_adapter.sh
source "$PROJECT_ROOT/lib/adapters/hash_adapter.sh"
# shellcheck source=lib/adapters/gpg.sh
source "$PROJECT_ROOT/lib/adapters/gpg.sh"
# shellcheck source=lib/cli/ui.sh
source "$PROJECT_ROOT/lib/cli/ui.sh"
# shellcheck source=lib/cli/args.sh
source "$PROJECT_ROOT/lib/cli/args.sh"
# shellcheck source=lib/utils/clipboard.sh
source "$PROJECT_ROOT/lib/utils/clipboard.sh"

# Internal: Executes verification for a single file/hash pair.
# Handles the flow for 'checkit <file> <hash>'.
#
# $1 - file - The file path to verify.
# $2 - hash - The expected hash string.
#
# Returns 0 on success, non-zero on failure.
do_verify_string() {
  local file="$1"
  local hash="$2"
  local algo

  # 1. Determine Algorithm Strategy
  if [[ "$__CLI_ALGO_SET" == "true" ]]; then
    algo="$__CLI_ALGO"
  else
    if ! algo=$(core::identify_algorithm "$hash"); then
      ui::log_error "$(ui::fmt_msg 'err_algo_id' "${#hash}")"
      return "$EX_OPERATIONAL_ERROR"
    fi
  fi

  # 2. Execute Primary Verification
  if hash_adapter::verify "$algo" "$file" "$hash"; then
    ui::log_file_status "$ST_OK" "$file" "$algo"
    return "$EX_SUCCESS"
  fi

  # 3. Resolve Ambiguity (Fallback Strategy)
  # If the user did not enforce an algorithm, try the fallback (e.g., sha256 -> blake2).
  if [[ "$__CLI_ALGO_SET" == "false" ]]; then
    local fallback_algo
    fallback_algo=$(hash_adapter::get_fallback_algo "$algo")

    if [[ -n "$fallback_algo" ]]; then
      if hash_adapter::verify "$fallback_algo" "$file" "$hash"; then
        ui::log_file_status "$ST_OK" "$file" "$fallback_algo"
        return "$EX_SUCCESS"
      fi
    fi
  fi

  # 4. Report Failure
  ui::log_file_status "$ST_FAIL" "$file" "$algo"
  return "$EX_INTEGRITY_FAIL"
}

# Internal: Main execution block.
# Parses arguments and switches between execution modes.
#
# $@ - Command line arguments.
#
# Returns the exit code of the operation.
main() {
  # 1. Parse CLI arguments and initialize global state
  if ! cli::parse_args "$@"; then
    exit "$EX_OPERATIONAL_ERROR"
  fi

  # 2. Dispatch Execution Mode
  case "$__CLI_MODE" in
  "verify_string")
    do_verify_string "$__CLI_FILE" "$__CLI_HASH"
    exit "$?"
    ;;

  "check")
    local sumfile="${__CLI_FILES[0]}"

    # --- SECURITY: GPG Verification ---
    if gpg::detect_signature "$sumfile"; then
      gpg_out=$(gpg::verify "$sumfile")
      gpg_status=$?

      if [[ "$gpg_status" -eq "$EX_SUCCESS" ]]; then
        # Signature Valid
        if [[ "$__CLI_QUIET" == "false" ]]; then
          ui::log_info "$(ui::get_msg 'msg_sig_good')"
        fi

      elif [[ "$gpg_status" -eq "$EX_SECURITY_FAIL" ]]; then
        # Signature Invalid
        if [[ "$__CLI_STRICT_SECURITY" == "true" ]]; then
          ui::log_critical "$(ui::get_msg 'err_sig_bad_strict')"
          echo "$gpg_out" >&2
          exit "$EX_SECURITY_FAIL"
        else
          ui::log_warning "$(ui::get_msg 'warn_sig_bad')"
        fi

      elif [[ "$gpg_status" -eq "$EX_OPERATIONAL_ERROR" ]]; then
        # Missing Key / Error
        if [[ "$__CLI_STRICT_SECURITY" == "true" ]]; then
          ui::log_error "$(ui::get_msg 'err_sig_missing_strict')"
          exit "$EX_SECURITY_FAIL"
        else
          if [[ "$__CLI_QUIET" == "false" ]]; then
            ui::log_warning "$(ui::get_msg 'warn_sig_missing')"
          fi
        fi
      fi
    else
      # No Signature Found
      if [[ "$__CLI_STRICT_SECURITY" == "true" ]]; then
        ui::log_error "$(ui::fmt_msg 'err_sig_not_found' "$sumfile")"
        exit "$EX_OPERATIONAL_ERROR"
      fi
    fi
    # --- End Security Block ---

    local algo_strategy="auto"
    if [[ "$__CLI_ALGO_SET" == "true" ]]; then
      algo_strategy="$__CLI_ALGO"
    fi

    # Clipboard Integration
    if [[ "$__CLI_COPY" == "true" ]]; then
      hash_adapter::check_list "$algo_strategy" "$sumfile" 2>&1 | tee >(utils::copy_to_clipboard)
      ui::log_clipboard "$(ui::get_msg 'msg_copy_ok')"
      exit "${PIPESTATUS[0]}"
    else
      hash_adapter::check_list "$algo_strategy" "$sumfile"
      exit "$?"
    fi
    ;;

  "create")
    # 1. Determine Target Algorithms
    local algos_to_run=()
    if [[ "$__CLI_ALL_ALGOS" == "true" ]]; then
      algos_to_run=("md5" "sha1" "sha256" "sha512" "blake2b")
    else
      algos_to_run=("$__CLI_ALGO")
    fi

    local output_buffer=""
    local has_error=false
    local first_item=true

    # 2. Initialize Output Buffer (Structured Formats)
    if [[ "$__CLI_OUTPUT_FMT" == "json" ]]; then
      output_buffer+="["
    elif [[ "$__CLI_OUTPUT_FMT" == "xml" ]]; then
      output_buffer+="<checksums>"
    fi

    # 3. Calculate Hashes
    for file in "${__CLI_FILES[@]}"; do
      # Fail fast validation
      if [[ ! -f "$file" ]]; then
        ui::log_file_status "$ST_MISSING" "$file"
        has_error=true
        continue
      fi

      for algo in "${algos_to_run[@]}"; do
        if raw_line=$(hash_adapter::calculate "$algo" "$file"); then
          local hash
          hash=$(echo "$raw_line" | awk '{print $1}')

          # Handle Separators (JSON/XML logic)
          if [[ "$__CLI_OUTPUT_FMT" == "json" ]]; then
            if [[ "$first_item" == "true" ]]; then
              output_buffer+=$'\n'
            else
              output_buffer+=","$'\n'
            fi
          elif [[ "$__CLI_OUTPUT_FMT" == "xml" ]]; then
            output_buffer+=$'\n'
          elif [[ "$first_item" == "false" ]]; then
            output_buffer+=$'\n'
          fi
          first_item=false

          # Format Output
          local formatted
          formatted=$(core::format_hash "$__CLI_OUTPUT_FMT" "$algo" "$file" "$hash")
          output_buffer+="$formatted"
        else
          # Error Handling
          ui::log_error "$(ui::fmt_msg 'err_calc_fail' "$algo" "$file")"
          has_error=true
        fi
      done
    done

    # 4. Finalize Output Buffer
    if [[ "$__CLI_OUTPUT_FMT" == "json" ]]; then
      output_buffer+=$'\n]'
    elif [[ "$__CLI_OUTPUT_FMT" == "xml" ]]; then
      output_buffer+=$'\n</checksums>'
    fi

    # 5. Output Management (Write/Sign)
    if [[ "$__CLI_SIGN_MODE" == "detach" && -z "$__CLI_OUTPUT_FILE" ]]; then
      __CLI_OUTPUT_FILE="CHECKSUMS"
    fi

    # Case A: Detached Signature
    if [[ "$__CLI_SIGN_MODE" == "detach" ]]; then
      mkdir -p "$(dirname "$__CLI_OUTPUT_FILE")"
      echo "$output_buffer" >"$__CLI_OUTPUT_FILE"

      if [[ "$__CLI_QUIET" == "false" ]]; then
        ui::log_info "$(ui::fmt_msg 'msg_saved' "$__CLI_OUTPUT_FILE")"
      fi

      if gpg::sign_file "$__CLI_OUTPUT_FILE" "$__CLI_SIGN_ARMOR"; then
        local ext=".sig"
        [[ "$__CLI_SIGN_ARMOR" == "true" ]] && ext=".asc"
        if [[ "$__CLI_QUIET" == "false" ]]; then
          ui::log_info "$(ui::fmt_msg 'msg_sig_created' "${__CLI_OUTPUT_FILE}${ext}")"
        fi
      else
        ui::log_error "$(ui::get_msg 'err_sig_detach_fail')"
        exit "$EX_OPERATIONAL_ERROR"
      fi

    # Case B: Inline Signature / Plain Output
    else
      # Sign buffer if requested (--sign)
      if [[ "$__CLI_SIGN_MODE" == "clear" ]]; then
        if [[ "$__CLI_OUTPUT_FMT" == "gnu" && "$__CLI_ALL_ALGOS" == "false" ]]; then
          local header_tag
          header_tag=$(core::get_tag "$__CLI_ALGO")
          output_buffer="Content-Hash: ${header_tag}"$'\n\n'"$output_buffer"
        fi

        if signed_content=$(gpg::sign_data "$output_buffer" "clear" "$__CLI_SIGN_ARMOR"); then
          output_buffer="$signed_content"
        else
          ui::log_error "$(ui::get_msg 'err_sig_fail')"
          exit "$EX_OPERATIONAL_ERROR"
        fi
      fi

      # Write final output (file or stdout)
      if [[ -n "$__CLI_OUTPUT_FILE" ]]; then
        mkdir -p "$(dirname "$__CLI_OUTPUT_FILE")"

        if [[ "$__CLI_ZERO" == "true" ]]; then
          printf "%s\0" "$output_buffer" >"$__CLI_OUTPUT_FILE"
        else
          echo "$output_buffer" >"$__CLI_OUTPUT_FILE"
        fi

        if [[ "$__CLI_QUIET" == "false" ]]; then
          ui::log_info "$(ui::fmt_msg 'msg_saved' "$__CLI_OUTPUT_FILE")"
        fi
      else
        if [[ "$__CLI_ZERO" == "true" ]]; then
          printf "%s\0" "$output_buffer"
        elif [[ -n "$output_buffer" ]]; then
          echo "$output_buffer"
        fi
      fi
    fi

    # 6. Clipboard Integration
    if [[ "$__CLI_COPY" == "true" && -n "$output_buffer" ]]; then
      if utils::copy_to_clipboard "$output_buffer"; then
        ui::log_clipboard "$(ui::get_msg 'msg_copy_ok')"
      fi
    fi
    if [[ "$has_error" == "true" ]]; then exit "$EX_OPERATIONAL_ERROR"; fi
    exit "$EX_SUCCESS"
    ;;

  *)
    exit "$EX_SUCCESS"
    ;;
  esac
}

main "$@"
