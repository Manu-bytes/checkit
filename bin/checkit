#!/usr/bin/env bash

# Resolves project root to locate libraries relative to this script.
BIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
PROJECT_ROOT="$(dirname "$BIN_DIR")"

# Library imports
# shellcheck source=lib/constants.sh
source "$PROJECT_ROOT/lib/constants.sh"
# shellcheck source=lib/core/algorithm_chooser.sh
source "$PROJECT_ROOT/lib/core/algorithm_chooser.sh"
# shellcheck source=lib/adapters/coreutils.sh
source "$PROJECT_ROOT/lib/adapters/coreutils.sh"
# shellcheck source=lib/cli/args.sh
source "$PROJECT_ROOT/lib/cli/args.sh"
# shellcheck source=lib/utils/clipboard.sh
source "$PROJECT_ROOT/lib/utils/clipboard.sh"

# do_verify_string
# Verification logic for direct file and hash arguments.
# Handles case: checkit <file> <hash>
do_verify_string() {
  local file="$1"
  local hash="$2"

  # 1. Heuristic algorithm identification.
  local algo
  if ! algo=$(core::identify_algorithm "$hash"); then
    echo "Error: Could not identify hash algorithm (length: ${#hash})."
    return "$EX_OPERATIONAL_ERROR"
  fi

  # 2. Integrity Verification
  coreutils::verify "$algo" "$file" "$hash"
  local status=$?

  # 3. Manage output based on global CLI flags.
  # Respects global flags like --quiet or --status if implemented.
  # Maintains standard output for current integration tests.
  if [[ "$status" -eq "$EX_SUCCESS" ]]; then
    if [[ "$__CLI_QUIET" == "false" && "$__CLI_STATUS" == "false" ]]; then
      echo "[OK] $file: Verified ($algo)"
    fi
    return "$EX_SUCCESS"
  elif [[ "$status" -eq "$EX_INTEGRITY_FAIL" ]]; then
    if [[ "$__CLI_STATUS" == "false" ]]; then
      echo "[FAILED] $file: Checksum mismatch ($algo)"
    fi
    return "$EX_INTEGRITY_FAIL"
  else
    echo "[ERROR] System error during verification"
    return "$status"
  fi
}

main() {
  # 1. Argument Parsing
  # Populates global variables: $__CLI_MODE, $__CLI_FILE, $__CLI_HASH, etc.
  if ! cli::parse_args "$@"; then
    # Parser prints error/help message; exit immediately.
    exit "$EX_OPERATIONAL_ERROR"
  fi

  # 2. Mode Dispatcher
  case "$__CLI_MODE" in
  "verify_string")
    # Explicit hash verification mode.
    do_verify_string "$__CLI_FILE" "$__CLI_HASH"
    exit "$?"
    ;;
  "check")
    local sumfile="${__CLI_FILES[0]}"

    # 1. Detect algorithm from checksum file.
    local algo
    if ! algo=$(core::identify_from_file "$sumfile"); then
      echo "Error: Could not identify algorithm from file: $sumfile"
      exit "$EX_OPERATIONAL_ERROR"
    fi

    coreutils::check_list "$algo" "$sumfile"
    local status=$?

    if [[ "$status" -eq "$EX_SUCCESS" ]]; then
      exit "$EX_SUCCESS"
    elif [[ "$status" -eq "$EX_INTEGRITY_FAIL" ]]; then
      exit "$EX_INTEGRITY_FAIL"
    else
      echo "[ERROR] System error during batch check"
      exit "$status"
    fi
    ;;
  "create")
    # Generation Mode (-n / implicit)
    local has_error=false
    local output_buffer=""

    for file in "${__CLI_FILES[@]}"; do
      # Captures output for buffer
      if hash_line=$(coreutils::calculate "$__CLI_ALGO" "$file"); then
        echo "$hash_line"

        # Accumulates in buffer for clipboard
        if [[ -n "$output_buffer" ]]; then
          output_buffer+=$'\n'
        fi
        output_buffer+="$hash_line"
      else
        echo "Error: Failed to calculate hash for $file" >&2
        has_error=true
      fi
    done

    # Clipboard Logic
    if [[ "$__CLI_COPY" == "true" && -n "$output_buffer" ]]; then
      if utils::copy_to_clipboard "$output_buffer"; then
        # Optional feedback message (stderr)
        echo "   [Context] Copied to clipboard." >&2
      else
        echo "   [Warning] Failed to copy (no clipboard tool found)." >&2
      fi
    fi

    if [[ "$has_error" == "true" ]]; then
      exit "$EX_OPERATIONAL_ERROR"
    fi

    exit "$EX_SUCCESS"
    ;;
  *)
    # If help or version, parse_args returns success but sets no mode.
    exit "$EX_SUCCESS"
    ;;
  esac
}

main "$@"
