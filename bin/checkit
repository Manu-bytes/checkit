#!/usr/bin/env bash

# Resolve project root to locate libraries relative to this script.
# Assuming structure: /path/to/project/bin/checkit
# Libraries at:       /path/to/project/lib/
BIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
PROJECT_ROOT="$(dirname "$BIN_DIR")"

# Import libraries
# shellcheck source=lib/constants.sh
source "$PROJECT_ROOT/lib/constants.sh"
# shellcheck source=lib/core/algorithm_chooser.sh
source "$PROJECT_ROOT/lib/core/algorithm_chooser.sh"
# shellcheck source=lib/adapters/coreutils.sh
source "$PROJECT_ROOT/lib/adapters/coreutils.sh"
# shellcheck source=lib/cli/args.sh
source "$PROJECT_ROOT/lib/cli/args.sh"

do_verify_string() {
  local file="$1"
  local hash="$2"

  # 1. Identify Algorithm (Heuristic)
  local algo
  if ! algo=$(core::identify_algorithm "$hash"); then
    echo "Error: Could not identify hash algorithm (length: ${#hash})."
    return "$EX_OPERATIONAL_ERROR"
  fi

  # 2. Verify Integrity
  coreutils::verify "$algo" "$file" "$hash"
  local status=$?

  # 3. Output Handling
  # We respect global flags such as --quiet or --status if they are implemented in the future,
  # but we maintain the standard output to pass the current integration tests.
  if [[ "$status" -eq "$EX_SUCCESS" ]]; then
    if [[ "$__CLI_QUIET" == "false" && "$__CLI_STATUS" == "false" ]]; then
      echo "[OK] $file: Verified ($algo)"
    fi
    return "$EX_SUCCESS"
  elif [[ "$status" -eq "$EX_INTEGRITY_FAIL" ]]; then
    if [[ "$__CLI_STATUS" == "false" ]]; then
      echo "[FAILED] $file: Checksum mismatch ($algo)"
    fi
    return "$EX_INTEGRITY_FAIL"
  else
    echo "[ERROR] System error during verification"
    return "$status"
  fi
}

main() {
  # 1. Parse Arguments
  # This fills the global variables: $__CLI_MODE, $__CLI_FILE, $__CLI_HASH, etc.
  if ! cli::parse_args "$@"; then
    # The parser already prints the error or help, so we just exit.
    exit "$EX_OPERATIONAL_ERROR"
  fi

  # 2. Mode Dispatcher
  case "$__CLI_MODE" in
  "verify_string")
    # Backward compatibility mode (File + Explicit Hash)
    do_verify_string "$__CLI_FILE" "$__CLI_HASH"
    exit "$?"
    ;;
  "check")
    local sumfile="${__CLI_FILES[0]}"

    # 1. Detection algorithm
    local algo
    if ! algo=$(core::identify_from_file "$sumfile"); then
      echo "Error: Could not identify algorithm from file: $sumfile"
      exit "$EX_OPERATIONAL_ERROR"
    fi

    # 2. Check list
    coreutils::check_list "$algo" "$sumfile"
    local status=$?

    # 3. Output
    if [[ "$status" -eq "$EX_SUCCESS" ]]; then
      if [[ "$__CLI_QUIET" == "false" && "$__CLI_STATUS" == "false" ]]; then
        echo "[OK] Batch verification passed ($algo)"
      fi
      exit "$EX_SUCCESS"
    elif [[ "$status" -eq "$EX_INTEGRITY_FAIL" ]]; then
      if [[ "$__CLI_STATUS" == "false" ]]; then
        echo "[FAILED] Batch verification failed ($algo)"
      fi
      exit "$EX_INTEGRITY_FAIL"
    else
      echo "[ERROR] System error during batch check"
      exit "$status"
    fi
    ;;
  "create")
    # Placeholder for Generation Mode (-n / implicit)
    # We iterate over all files passed as arguments
    # (checkit file1 file2 ...)
    local has_error=false

    for file in "${__CLI_FILES[@]}"; do
      # We use the algorithm defined in CLI (default: sha256)
      if ! coreutils::calculate "$__CLI_ALGO" "$file"; then
        echo "Error: Failed to calculate hash for $file" >&2
        has_error=true
      fi
    done

    if [[ "$has_error" == "true" ]]; then
      exit "$EX_OPERATIONAL_ERROR"
    fi

    exit "$EX_SUCCESS"
    ;;
  *)
    # If it is help or version, parse_args returned success but did not set the execution mode.
    exit "$EX_SUCCESS"
    ;;
  esac
}

main "$@"
