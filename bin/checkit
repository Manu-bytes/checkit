#!/usr/bin/env bash

# Resolves project root to locate libraries relative to this script.
BIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
PROJECT_ROOT="$(dirname "$BIN_DIR")"

# Library imports
# shellcheck source=lib/constants.sh
source "$PROJECT_ROOT/lib/constants.sh"
# shellcheck source=lib/core/parser.sh
source "$PROJECT_ROOT/lib/core/parser.sh"
# shellcheck source=lib/core/formatter.sh
source "$PROJECT_ROOT/lib/core/formatter.sh"
# shellcheck source=lib/core/algorithm_chooser.sh
source "$PROJECT_ROOT/lib/core/algorithm_chooser.sh"
# shellcheck source=lib/adapters/coreutils.sh
source "$PROJECT_ROOT/lib/adapters/coreutils.sh"
# shellcheck source=lib/adapters/gpg.sh
source "$PROJECT_ROOT/lib/adapters/gpg.sh"
# shellcheck source=lib/cli/args.sh
source "$PROJECT_ROOT/lib/cli/args.sh"
# shellcheck source=lib/utils/clipboard.sh
source "$PROJECT_ROOT/lib/utils/clipboard.sh"

# do_verify_string
# Verification logic for direct file and hash arguments.
# Handles case: checkit <file> <hash>
do_verify_string() {
  local file="$1"
  local hash="$2"
  local algo

  # 1. Determine Algorithm Strategy
  if [[ "$__CLI_ALGO_SET" == "true" ]]; then
    # Priority A: User explicit request
    algo="$__CLI_ALGO"
  else
    # Priority B: Heuristic identification
    if ! algo=$(core::identify_algorithm "$hash"); then
      echo "Error: Could not identify hash algorithm (length: ${#hash})."
      return "$EX_OPERATIONAL_ERROR"
    fi
  fi

  # 2. Primary Verification Attempt
  # We use a subshell or capture exit code specifically to handle the fallback logic logic manually
  if coreutils::verify "$algo" "$file" "$hash"; then
    echo "[OK] $file ($algo)"
    return "$EX_SUCCESS"
  fi

  # 3. Ambiguity Resolution (Fallback)
  # Only attempt if the user did NOT enforce a specific algorithm via --algo
  if [[ "$__CLI_ALGO_SET" == "false" ]]; then
    local fallback_algo
    fallback_algo=$(coreutils::get_fallback_algo "$algo")

    if [[ -n "$fallback_algo" ]]; then
      # Retry with fallback
      if coreutils::verify "$fallback_algo" "$file" "$hash"; then
        echo "[OK] $file ($fallback_algo)"
        return "$EX_SUCCESS"
      fi
    fi
  fi

  # 4. Final Failure Report
  echo "[FAILED] $file ($algo)"
  return "$EX_INTEGRITY_FAIL"
}

main() {
  # 1. Argument Parsing
  # Populates global variables: $__CLI_MODE, $__CLI_FILE, $__CLI_HASH, etc.
  if ! cli::parse_args "$@"; then
    # Parser prints error/help message; exit immediately.
    exit "$EX_OPERATIONAL_ERROR"
  fi

  # 2. Mode Dispatcher
  case "$__CLI_MODE" in
  "verify_string")
    # Explicit hash verification mode.
    do_verify_string "$__CLI_FILE" "$__CLI_HASH"
    exit "$?"
    ;;
  "check")
    local sumfile="${__CLI_FILES[0]}"
    # --- SECURITY: GPG VERIFICATION BLOCK ---
    if gpg::detect_signature "$sumfile"; then
      gpg_out=$(gpg::verify "$sumfile")
      gpg_status=$?

      if [[ "$gpg_status" -eq "$EX_SUCCESS" ]]; then
        # Happy Path
        if [[ "$__CLI_QUIET" == "false" ]]; then
          echo "[INFO] Signature Verified: Good signature found."
        fi

      elif [[ "$gpg_status" -eq "$EX_SECURITY_FAIL" ]]; then
        # BAD SIGNATURE DETECTED
        if [[ "$__CLI_STRICT_SECURITY" == "true" ]]; then
          echo "[CRITICAL] BAD signature detected. Aborting strict mode." >&2
          echo "$gpg_out" >&2
          exit "$EX_SECURITY_FAIL"
        else
          # Auto Mode: Warn but proceed
          echo "[WARNING] BAD signature detected. Integrity of list is compromised." >&2
        fi

      elif [[ "$gpg_status" -eq "$EX_OPERATIONAL_ERROR" ]]; then
        # MISSING KEY / GPG ERROR
        if [[ "$__CLI_STRICT_SECURITY" == "true" ]]; then
          echo "[ERROR] Public key missing or GPG error. Cannot verify strict." >&2
          exit "$EX_SECURITY_FAIL"
        else
          # Auto Mode: Info only
          if [[ "$__CLI_QUIET" == "false" ]]; then
            echo "[INFO] Signed file detected, but Public key missing. Proceeding with hash check."
          fi
        fi
      fi
    else
      # No signature detected
      if [[ "$__CLI_STRICT_SECURITY" == "true" ]]; then
        echo "Error: --verify-sign requested but no signature found in $sumfile"
        exit "$EX_OPERATIONAL_ERROR"
      fi
    fi
    # --- END SECURITY BLOCK ---

    coreutils::check_list "auto" "$sumfile"
    exit $?
    ;;
  "create")
    # 1. Determine Algorithms
    local algos_to_run=()
    if [[ "$__CLI_ALL_ALGOS" == "true" ]]; then
      # Standard safe list
      algos_to_run=("md5" "sha1" "sha256" "sha512" "blake2b")
    else
      # Default behavior: Single algo (preserves legacy tests)
      algos_to_run=("$__CLI_ALGO")
    fi

    local output_buffer=""
    local has_error=false
    local first_item=true

    # 2. Header for Structured Formats
    if [[ "$__CLI_OUTPUT_FMT" == "json" ]]; then
      output_buffer+="["
    elif [[ "$__CLI_OUTPUT_FMT" == "xml" ]]; then
      output_buffer+="<checksums>"
    fi

    # 3. Main Loop
    for file in "${__CLI_FILES[@]}"; do
      # Fail fast validation (Standard behavior)
      if [[ ! -f "$file" ]]; then
        echo "checkit: $file: No such file or directory" >&2
        has_error=true
        continue
      fi

      for algo in "${algos_to_run[@]}"; do
        # Execute Calculation
        # coreutils::calculate returns standard "HASH  FILE" string
        if raw_line=$(coreutils::calculate "$algo" "$file"); then

          # Extract Hash (assuming standard GNU format output from adapter)
          # $1 is hash, $2... is filename (handled by formatter separately)
          local hash
          hash=$(echo "$raw_line" | awk '{print $1}')

          # Handle Separators (JSON logic)
          if [[ "$__CLI_OUTPUT_FMT" == "json" ]]; then
            if [[ "$first_item" == "true" ]]; then
              output_buffer+=$'\n'
            else
              output_buffer+=","$'\n'
            fi
          elif [[ "$__CLI_OUTPUT_FMT" == "xml" ]]; then
            output_buffer+=$'\n'
          elif [[ "$first_item" == "false" ]]; then
            # Standard newline for text modes
            output_buffer+=$'\n'
          fi
          first_item=false

          # Format Output
          # Defaults to "gnu" which replicates original behavior exactly
          local formatted
          formatted=$(core::format_hash "$__CLI_OUTPUT_FMT" "$algo" "$file" "$hash")
          output_buffer+="$formatted"
        else
          echo "Error: Failed to calculate $algo for $file" >&2
          has_error=true
        fi
      done
    done

    # 4. Footer for Structured Formats
    if [[ "$__CLI_OUTPUT_FMT" == "json" ]]; then
      output_buffer+=$'\n]'
    elif [[ "$__CLI_OUTPUT_FMT" == "xml" ]]; then
      output_buffer+=$'\n</checksums>'
    fi

    # 5. Signing Logic (Optional)
    if [[ "$__CLI_SIGN" == "true" ]]; then

      if [[ "$__CLI_OUTPUT_FMT" == "gnu" && "$__CLI_ALL_ALGOS" == "false" ]]; then
        # MIME-style format: Header + blank line + body
        output_buffer="Content-Hash: ${__CLI_ALGO}"$'\n\n'"$output_buffer"
      fi

      if signed_content=$(gpg::clearsign_content "$output_buffer"); then
        output_buffer="$signed_content"
      else
        echo "Error: GPG signing failed." >&2
        exit "$EX_OPERATIONAL_ERROR"
      fi
    fi

    # 6. Final Output (Replaces the inline echo)
    if [[ "$__CLI_ZERO" == "true" ]]; then
      printf "%s\0" "$output_buffer"
    else
      # If buffer is empty (e.g. no files found), echo nothing just like loop would
      if [[ -n "$output_buffer" ]]; then
        echo "$output_buffer"
      fi
    fi

    # 7. Clipboard Logic (Preserved)
    if [[ "$__CLI_COPY" == "true" && -n "$output_buffer" ]]; then
      if utils::copy_to_clipboard "$output_buffer"; then
        echo "   [Context] Copied to clipboard." >&2
      else
        echo "   [Warning] Failed to copy (no clipboard tool found)." >&2
      fi
    fi

    if [[ "$has_error" == "true" ]]; then exit "$EX_OPERATIONAL_ERROR"; fi
    exit "$EX_SUCCESS"
    ;;
  *)
    # If help or version, parse_args returns success but sets no mode.
    exit "$EX_SUCCESS"
    ;;
  esac
}

main "$@"
